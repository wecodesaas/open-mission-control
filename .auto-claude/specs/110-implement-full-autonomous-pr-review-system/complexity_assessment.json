{
  "complexity": "complex",
  "workflow_type": "feature",
  "confidence": 0.95,
  "reasoning": "This is a large-scale, 7-phase feature spanning 6-8 weeks with 20+ files across frontend and backend services. It introduces new architectural patterns (circuit breakers, state persistence, security layer), extends the core state machine, and requires security-critical components (authorization, input sanitization). The cross-cutting nature and security implications make this unambiguously complex.",

  "analysis": {
    "scope": {
      "estimated_files": 20,
      "estimated_services": 2,
      "is_cross_cutting": true,
      "notes": "Backend: 11 files (lifecycle.py, audit.py, 8 new modules, client.py). Frontend: 9 files (hooks, components, IPC handlers, types, i18n). State machine changes cascade throughout the GitHub integration pipeline."
    },
    "integrations": {
      "external_services": ["GitHub API"],
      "new_dependencies": ["structlog"],
      "research_needed": true,
      "notes": "Uses existing GitHub API but with new patterns (CI check polling, bot comment verification). Circuit breaker and exponential backoff patterns need research for reliability. Claude Agent SDK extended with new pr_fixer agent type."
    },
    "infrastructure": {
      "docker_changes": false,
      "database_changes": false,
      "config_changes": true,
      "notes": "New env vars: GITHUB_AUTO_PR_REVIEW_ENABLED, GITHUB_AUTO_PR_REVIEW_ALLOWED_USERS. State persistence via JSON files with file locking for crash recovery. No Docker or database schema changes required."
    },
    "knowledge": {
      "patterns_exist": true,
      "research_required": true,
      "unfamiliar_tech": ["circuit breaker patterns", "structlog", "exponential backoff with jitter"],
      "notes": "Existing patterns: agent types, IssueLifecycle state machine, IPC handlers, i18n. New patterns needed: circuit breakers for API resilience, checkpointed state persistence for crash recovery, input sanitization layer, permission management with audit trails."
    },
    "risk": {
      "level": "high",
      "concerns": [
        "State machine changes could affect existing GitHub integration workflows",
        "Security-critical: authorization bypass could allow unauthorized PR automation",
        "Input sanitization: prompt injection via GitHub issue content or bot comments",
        "Concurrency: race conditions between multiple PR reviews or manual actions",
        "Crash recovery: incomplete state could leave PRs in limbo",
        "Human approval enforcement: any path to auto-merge is critical security failure"
      ],
      "notes": "The explicit requirement for NEVER auto-merge and mandatory human approval adds security complexity. Bot identity verification, permission allowlists, and input sanitization are security-critical components that must be implemented correctly."
    }
  },

  "recommended_phases": [
    "discovery",
    "requirements",
    "research",
    "context",
    "spec_writing",
    "self_critique",
    "planning",
    "validation"
  ],

  "flags": {
    "needs_research": true,
    "needs_self_critique": true,
    "needs_infrastructure_setup": false
  },

  "validation_recommendations": {
    "risk_level": "high",
    "skip_validation": false,
    "minimal_mode": false,
    "test_types_required": ["unit", "integration", "e2e"],
    "security_scan_required": true,
    "staging_deployment_required": false,
    "reasoning": "Security-critical feature with authorization, input sanitization, and human-approval enforcement. Cross-cutting state machine changes require comprehensive testing including unit tests for individual components (InputSanitizer, PermissionManager, PRCheckWaiter), integration tests for the orchestrator flow, and E2E tests for frontend interactions. Security scan needed for prompt injection defenses and authorization bypass vulnerabilities. No staging deployment required as there are no external infrastructure dependencies."
  },

  "phase_specific_guidance": {
    "research": {
      "topics_to_research": [
        "Circuit breaker patterns in Python (async context)",
        "Exponential backoff with jitter best practices",
        "structlog for structured logging in Python",
        "GitHub API rate limiting and error handling patterns",
        "Input sanitization against prompt injection"
      ],
      "estimated_duration": "2-3 hours"
    },
    "self_critique": {
      "focus_areas": [
        "Security: Can authorization be bypassed? Are all inputs sanitized?",
        "State machine: Are all transitions valid? Can we get stuck in invalid states?",
        "Concurrency: Are race conditions handled? Is locking comprehensive?",
        "Recovery: Can we resume from any checkpoint? What if checkpoint is corrupted?",
        "Human approval: Is there ANY code path that could auto-merge?"
      ],
      "recommended_perspectives": ["security", "backend_architect", "qa"]
    }
  },

  "implementation_notes": {
    "suggested_order": "Phase 0 (foundation) â†’ Phase 1 (security) must complete before Phase 2-3 (backend) can start. Frontend (Phase 4) can partially parallelize with Phase 2-3. Observability (Phase 5) and Testing (Phase 6) follow. Rollout (Phase 7) is post-implementation.",
    "critical_dependencies": [
      "IssueLifecycleState enum extension blocks all other state machine work",
      "InputSanitizer blocks PRFixerAgent (fixer receives external content)",
      "PermissionManager blocks AutoPRReviewOrchestrator",
      "FrontendStateAdapter blocks frontend progress display"
    ],
    "parallelization_opportunities": [
      "Security modules (InputSanitizer, PermissionManager, BotVerifier) can be built in parallel",
      "Frontend UI components can be built while backend orchestrator is in progress",
      "Unit tests can be written alongside implementation"
    ]
  },

  "created_at": "2026-01-08T12:00:00Z"
}

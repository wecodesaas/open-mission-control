{
  "integrations_researched": [
    {
      "name": "Claude Agent SDK",
      "type": "library",
      "verified_package": {
        "name": "claude-agent-sdk",
        "install_command": "pip install claude-agent-sdk>=0.1.16",
        "version": ">=0.1.16",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from claude_agent_sdk import query, ClaudeAgentOptions, AssistantMessage, TextBlock",
          "from claude_agent_sdk import ClaudeSDKClient"
        ],
        "initialization": "client = create_client(agent_type='pr_fixer', model='claude-sonnet-4-5-20250929')",
        "key_functions": [
          "query(prompt='...')",
          "ClaudeSDKClient.create_agent_session(name='...', starting_message='...')",
          "Custom tools via in-process MCP servers"
        ],
        "verified_against": "Context7 MCP + Anthropic Official Docs + Existing codebase (core/client.py)"
      },
      "configuration": {
        "env_vars": ["CLAUDE_CODE_OAUTH_TOKEN"],
        "config_files": [],
        "dependencies": ["Node.js 18+"]
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "CRITICAL: Use create_client() from core.client, NEVER use Anthropic API directly",
        "Agent types must be added to client.py switch statement for new agents like 'pr_fixer'",
        "SDK has automatic context summarization when approaching context limits",
        "Requires Python 3.10+ and Node.js 18+"
      ],
      "research_sources": [
        "https://platform.claude.com/docs/en/agent-sdk/overview",
        "https://github.com/anthropics/claude-agent-sdk-python",
        "Existing codebase: apps/backend/core/client.py"
      ],
      "existing_in_project": true,
      "project_location": "apps/backend/requirements.txt, apps/backend/core/client.py"
    },
    {
      "name": "structlog",
      "type": "library",
      "verified_package": {
        "name": "structlog",
        "install_command": "pip install structlog",
        "version": ">=25.5.0",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "import structlog",
          "from structlog import get_logger"
        ],
        "initialization": "structlog.configure(processors=[...], wrapper_class=..., logger_factory=...)",
        "key_functions": [
          "structlog.get_logger()",
          "logger.bind(correlation_id=..., pr_number=...)",
          "logger.info('event.name', key='value')",
          "structlog.stdlib.recreate_defaults()"
        ],
        "verified_against": "Context7 MCP + Official Docs (structlog.org)"
      },
      "configuration": {
        "env_vars": ["FORCE_COLOR"],
        "config_files": [],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "Call structlog.configure() at app initialization ONCE",
        "Bound loggers are the centerpiece - call get_logger() then .bind() for context",
        "Processor chains transform log events - order matters",
        "Use structlog.stdlib.recreate_defaults() for quick stdlib integration",
        "Project currently uses standard logging module - migration needed"
      ],
      "research_sources": [
        "https://www.structlog.org/en/stable/getting-started.html",
        "https://www.structlog.org/en/stable/bound-loggers.html",
        "https://www.structlog.org/en/stable/configuration.html"
      ],
      "existing_in_project": false,
      "needs_installation": true
    },
    {
      "name": "PyGithub",
      "type": "library",
      "verified_package": {
        "name": "PyGithub",
        "install_command": "pip install PyGithub",
        "version": ">=2.8.1",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from github import Github",
          "from github import Auth"
        ],
        "initialization": "g = Github(auth=Auth.Token('token'))",
        "key_functions": [
          "repo.get_pull(pr_number)",
          "pr.get_commits()",
          "commit.get_combined_status()",
          "pr.create_review(body=..., event='APPROVE'|'REQUEST_CHANGES')"
        ],
        "verified_against": "PyGithub Official Docs + GitHub Issues"
      },
      "configuration": {
        "env_vars": ["GITHUB_TOKEN"],
        "config_files": [],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "CRITICAL: PyGithub does NOT expose PR Checks API directly - see issue #1621",
        "To get PR checks: get last commit SHA, then use commit.get_check_runs()",
        "For combined status use commit.get_combined_status() but this is different from Checks",
        "Project already uses 'gh' CLI via subprocess which has better Checks support",
        "Consider using raw requests or gh CLI for check_runs endpoint"
      ],
      "research_sources": [
        "https://pygithub.readthedocs.io/en/latest/github_objects/PullRequest.html",
        "https://github.com/PyGithub/PyGithub/issues/1621",
        "https://pypi.org/project/PyGithub/"
      ],
      "existing_in_project": false,
      "alternative_approach": "Use existing gh CLI subprocess pattern (see gh_client.py)"
    },
    {
      "name": "pybreaker (Circuit Breaker)",
      "type": "library",
      "verified_package": {
        "name": "pybreaker",
        "install_command": "pip install pybreaker",
        "version": ">=1.3.0",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from pybreaker import CircuitBreaker, CircuitBreakerError"
        ],
        "initialization": "cb = CircuitBreaker(fail_max=3, reset_timeout=300)",
        "key_functions": [
          "@cb decorator on functions",
          "cb.call(func, *args)",
          "cb.state (closed/open/half-open)",
          "Listeners: before_call, state_change, failure, success"
        ],
        "verified_against": "GitHub README + PyPI"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false,
        "optional_redis": "CircuitRedisStorage for distributed state"
      },
      "gotchas": [
        "CircuitBreaker instances should live GLOBALLY (singleton pattern)",
        "fail_max=5 and reset_timeout=30s are defaults",
        "success_threshold option requires multiple successful calls to close circuit",
        "throw_new_error_on_trip=False keeps original error",
        "For Redis storage: DON'T use decode_responses=True",
        "Use unique namespace for multiple circuit breakers with Redis"
      ],
      "research_sources": [
        "https://github.com/danielfm/pybreaker",
        "https://pypi.org/project/pybreaker/"
      ],
      "existing_in_project": false,
      "needs_installation": true,
      "alternative": {
        "name": "circuitbreaker",
        "install_command": "pip install circuitbreaker",
        "version": ">=2.1.3",
        "notes": "Different API but similar concept - failure_threshold, recovery_timeout, expected_exception, fallback_function"
      }
    },
    {
      "name": "filelock",
      "type": "library",
      "verified_package": {
        "name": "filelock",
        "install_command": "pip install filelock",
        "version": ">=3.20.0",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from filelock import FileLock, SoftFileLock, Timeout"
        ],
        "initialization": "lock = FileLock('/path/to/file.lock')",
        "key_functions": [
          "with lock: ...",
          "lock.acquire(timeout=10)",
          "lock.release()",
          "lock.is_locked"
        ],
        "verified_against": "Official Docs (py-filelock.readthedocs.io) + PyPI"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "Use FileLock for platform-dependent OS locks (handles crashes automatically)",
        "SoftFileLock is portable but prone to deadlocks if process crashes",
        "DON'T lock the file you're writing to - create a separate .lock file",
        "FileLock became thread-local in v3.11.0",
        "Context manager (with statement) auto-releases on exit",
        "For crash recovery: FileLock preferred since OS releases lock on process death"
      ],
      "research_sources": [
        "https://py-filelock.readthedocs.io/",
        "https://pypi.org/project/filelock/",
        "https://github.com/tox-dev/filelock"
      ],
      "existing_in_project": false,
      "needs_installation": true
    },
    {
      "name": "react-i18next",
      "type": "library",
      "verified_package": {
        "name": "react-i18next",
        "install_command": "npm install react-i18next",
        "version": "latest",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "import { useTranslation } from 'react-i18next'"
        ],
        "initialization": "const { t } = useTranslation(['namespace1', 'namespace2'])",
        "key_functions": [
          "t('namespace:key.path')",
          "t('key', { interpolation: 'value' })",
          "<Trans> component for complex translations"
        ],
        "verified_against": "Context7 MCP + Project codebase"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [
          "apps/frontend/src/shared/i18n/locales/en/*.json",
          "apps/frontend/src/shared/i18n/locales/fr/*.json"
        ],
        "dependencies": ["i18next"]
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "CRITICAL: All user-facing text MUST use translation keys per CLAUDE.md",
        "Namespace format: common.json, navigation.json, settings.json, github.json",
        "Add keys to ALL language files (en AND fr minimum)",
        "Use namespace:section.key format (e.g., 'autoPRReview.status.awaiting_checks')"
      ],
      "research_sources": [
        "https://react.i18next.com/",
        "Existing codebase: apps/frontend/src/shared/i18n/"
      ],
      "existing_in_project": true,
      "project_location": "apps/frontend/src/shared/i18n/"
    },
    {
      "name": "Electron IPC",
      "type": "infrastructure",
      "verified_package": {
        "name": "electron",
        "install_command": "npm install electron",
        "version": "current project version",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "import { ipcMain, ipcRenderer } from 'electron'",
          "import { contextBridge } from 'electron'"
        ],
        "initialization": "// Main: ipcMain.handle(channel, handler)\n// Preload: contextBridge.exposeInMainWorld('api', {...})",
        "key_functions": [
          "ipcMain.handle(channel, async (event, ...args) => {...})",
          "ipcMain.on(channel, (event, ...args) => {...})",
          "mainWindow.webContents.send(channel, data)",
          "ipcRenderer.invoke(channel, ...args)"
        ],
        "verified_against": "Electron Official Docs + Project codebase"
      },
      "configuration": {
        "env_vars": [],
        "config_files": ["apps/frontend/src/shared/constants.ts (IPC_CHANNELS)"],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "NEVER expose ipcRenderer directly - wrap in helper functions via contextBridge",
        "Add new channels to IPC_CHANNELS constant in shared/constants.ts",
        "Use ipcMain.handle() for request-response, ipcMain.on() for events",
        "Preload scripts are sandboxed since Electron 20",
        "Follow existing patterns in apps/frontend/src/main/ipc-handlers/github/"
      ],
      "research_sources": [
        "https://www.electronjs.org/docs/latest/tutorial/ipc",
        "https://www.electronjs.org/docs/latest/tutorial/context-isolation",
        "Existing codebase: apps/frontend/src/main/ipc-handlers/"
      ],
      "existing_in_project": true,
      "project_location": "apps/frontend/src/main/ipc-handlers/github/autofix-handlers.ts"
    },
    {
      "name": "ContentSanitizer (Input Sanitization)",
      "type": "infrastructure",
      "verified_package": {
        "name": "Internal module",
        "install_command": "Already exists",
        "version": "Current",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from runners.github.sanitize import ContentSanitizer, get_sanitizer",
          "from runners.github.sanitize import sanitize_github_content, wrap_for_prompt"
        ],
        "initialization": "sanitizer = ContentSanitizer() or get_sanitizer()",
        "key_functions": [
          "sanitizer.sanitize_issue_body(body)",
          "sanitizer.sanitize_pr_body(body)",
          "sanitizer.sanitize_comment(comment)",
          "sanitizer.wrap_user_content(content, content_type)",
          "get_prompt_safety_prefix()",
          "get_prompt_safety_suffix()"
        ],
        "verified_against": "Existing codebase"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "Already implements prompt injection detection patterns from OWASP guidelines",
        "Content limits: 10KB issue/PR body, 100KB diff, 50KB file, 5KB comment",
        "Removes HTML comments, script/style tags automatically",
        "Use wrap_user_content() + prompt safety prefix/suffix for agent prompts",
        "OutputValidator class validates AI output format"
      ],
      "research_sources": [
        "Existing codebase: apps/backend/runners/github/sanitize.py"
      ],
      "existing_in_project": true,
      "project_location": "apps/backend/runners/github/sanitize.py",
      "can_be_extended": true
    },
    {
      "name": "RateLimiter (Token Bucket + Exponential Backoff)",
      "type": "infrastructure",
      "verified_package": {
        "name": "Internal module",
        "install_command": "Already exists",
        "version": "Current",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from runners.github.rate_limiter import RateLimiter, rate_limited",
          "from runners.github.rate_limiter import RateLimitExceeded, CostLimitExceeded"
        ],
        "initialization": "limiter = RateLimiter.get_instance(github_limit=5000, cost_limit=10.0)",
        "key_functions": [
          "await limiter.acquire_github(timeout=30.0)",
          "limiter.track_ai_cost(input_tokens, output_tokens, model)",
          "@rate_limited(operation_type='github', max_retries=3, base_delay=1.0)",
          "limiter.check_github_available()",
          "limiter.statistics()"
        ],
        "verified_against": "Existing codebase"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "Singleton pattern - use RateLimiter.get_instance()",
        "TokenBucket implementation with automatic refill (5000/hour GitHub)",
        "Includes exponential backoff with max_retry_delay=300s (5 min)",
        "AI cost tracking with per-model pricing",
        "Already has @rate_limited decorator - can be extended for PR polling"
      ],
      "research_sources": [
        "Existing codebase: apps/backend/runners/github/rate_limiter.py"
      ],
      "existing_in_project": true,
      "project_location": "apps/backend/runners/github/rate_limiter.py",
      "can_be_extended": true
    },
    {
      "name": "IssueLifecycle State Machine",
      "type": "infrastructure",
      "verified_package": {
        "name": "Internal module",
        "install_command": "Already exists",
        "version": "Current",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "from runners.github.lifecycle import IssueLifecycleState, IssueLifecycle",
          "from runners.github.lifecycle import LifecycleManager, VALID_TRANSITIONS"
        ],
        "initialization": "lifecycle_mgr = LifecycleManager(state_dir=Path('.auto-claude/github'))",
        "key_functions": [
          "lifecycle_mgr.get_or_create(repo, issue_number)",
          "lifecycle.transition(new_state, actor, reason)",
          "lifecycle.acquire_lock(component)",
          "lifecycle.release_lock(component)",
          "lifecycle.can_transition_to(state)"
        ],
        "verified_against": "Existing codebase"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": []
      },
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "VALID_TRANSITIONS dict defines allowed state changes",
        "Locking already implemented (acquire_lock/release_lock)",
        "State persisted to JSON files in .auto-claude/github/lifecycle/",
        "Requirements specify adding: PR_AWAITING_CHECKS, PR_FIXING, PR_READY_TO_MERGE states",
        "ConflictResult pattern for error handling"
      ],
      "research_sources": [
        "Existing codebase: apps/backend/runners/github/lifecycle.py"
      ],
      "existing_in_project": true,
      "project_location": "apps/backend/runners/github/lifecycle.py",
      "requires_modification": true
    }
  ],
  "unverified_claims": [
    {
      "claim": "CodeRabbit and Cursor bots have parseable comment formats",
      "reason": "No documentation found on exact comment formats - need to inspect actual bot comments",
      "risk_level": "medium",
      "mitigation": "Implement generic parser with fallback, inspect real comments during development"
    },
    {
      "claim": "GitHub bot account IDs are stable and can be used for verification",
      "reason": "GitHub documentation doesn't explicitly guarantee account ID stability",
      "risk_level": "low",
      "mitigation": "Use account ID + name + verification status combination"
    }
  ],
  "recommendations": [
    {
      "category": "dependencies",
      "recommendation": "Install pybreaker>=1.3.0 and filelock>=3.20.0 for circuit breaker and crash recovery",
      "priority": "high"
    },
    {
      "category": "dependencies",
      "recommendation": "Install structlog>=25.5.0 for structured logging with correlation IDs",
      "priority": "medium"
    },
    {
      "category": "reuse",
      "recommendation": "Extend existing ContentSanitizer for InputSanitizer - already has prompt injection patterns",
      "priority": "high"
    },
    {
      "category": "reuse",
      "recommendation": "Extend existing RateLimiter TokenBucket for PRCheckWaiter polling with exponential backoff",
      "priority": "high"
    },
    {
      "category": "reuse",
      "recommendation": "Extend existing IssueLifecycle state machine rather than creating new state tracker",
      "priority": "critical"
    },
    {
      "category": "github_api",
      "recommendation": "Use gh CLI for PR checks (existing pattern) rather than PyGithub due to Checks API limitations",
      "priority": "high"
    },
    {
      "category": "patterns",
      "recommendation": "Follow existing IPC handler patterns in autofix-handlers.ts for new Auto-PR-Review handlers",
      "priority": "medium"
    }
  ],
  "context7_libraries_used": [
    "/hynek/structlog",
    "/pygithub/pygithub",
    "/danielfm/pybreaker",
    "/i18next/react-i18next"
  ],
  "new_dependencies_required": [
    {
      "package": "structlog",
      "version": ">=25.5.0",
      "purpose": "Structured logging with bound context and correlation IDs"
    },
    {
      "package": "pybreaker",
      "version": ">=1.3.0",
      "purpose": "Circuit breaker pattern for PR check polling reliability"
    },
    {
      "package": "filelock",
      "version": ">=3.20.0",
      "purpose": "File-based locking for crash recovery state persistence"
    }
  ],
  "existing_infrastructure_to_extend": [
    {
      "module": "runners/github/sanitize.py",
      "class": "ContentSanitizer",
      "extension_needed": "Add file path validation, dangerous Unicode stripping",
      "creates": "InputSanitizer (subclass or extension)"
    },
    {
      "module": "runners/github/rate_limiter.py",
      "class": "TokenBucket + RateLimiter",
      "extension_needed": "Add circuit breaker integration, PR polling backoff",
      "creates": "PRCheckWaiter uses these patterns"
    },
    {
      "module": "runners/github/lifecycle.py",
      "class": "IssueLifecycleState + LifecycleManager",
      "extension_needed": "Add PR_AWAITING_CHECKS, PR_FIXING, PR_READY_TO_MERGE states",
      "creates": "Extended state machine for PR review loop"
    }
  ],
  "created_at": "2025-01-08T15:30:00Z"
}

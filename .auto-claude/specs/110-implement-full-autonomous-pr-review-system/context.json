{
  "task_description": "# Full Autonomous PR Review and Fix System - REVISED Implementation Plan\n\n## Executive Summary\n\nThis plan has been **revised** based on comprehensive critiques from 5 expert perspectives:\n- **Backend Architect**: State machine integration, concurrency control\n- **Frontend/UX Engineer**: Real-time feedback, cancellation UX, accessibility\n- **DevOps/SRE Engineer**: State persistence, circuit breakers, observability\n- **Security Engineer**: Authorization, input sanitization, human approval requirement\n- **QA Engineer**: Edge cases, error handling, test coverage\n\n**Original Timeline**: 4 phases (underestimated)\n**Revised Timeline**: 7 phases (~6-8 weeks for production-ready system)\n\n---\n\n## Critical Design Decisions (Updated)\n\n### \u26a0\ufe0f MANDATORY: Human Approval Before Merge\n**The system will NEVER auto-merge.** Final state is \"Ready for Human Review\" - a human MUST click merge.\n\n### State Machine: Single Source of Truth\nUse existing `IssueLifecycle` in `lifecycle.py` as the ONLY state machine. Frontend `AutoFixQueueItem.status` becomes a **view** of backend state via adapter.\n\n### Concurrency: Mandatory Locking\nEvery orchestrator operation MUST acquire lock via `LifecycleManager.acquire_lock()` before proceeding.\n\n### Security: Authorization Required\nAuto-PR-Review can only be triggered by users in `GITHUB_AUTO_PR_REVIEW_ALLOWED_USERS` allowlist.\n\n---\n\n## User Requirements (Confirmed)\n- **Two separate toggles**: \"Auto-Fix Issues\" (exists) + new \"Auto-PR-Review\" toggle\n- **Auto-create PR after QA passes**: PR created automatically\n- **Wait for all checks**: CI + external bots (CodeRabbit, etc.) before internal review\n- **Ready for Human Review**: Final status with \"PR Ready to Merge\" indicator\n- **Human approval REQUIRED**: System prepares PR, human decides to merge\n\n---\n\n## Architecture (Revised)\n\n### Unified State Machine\n\n```\nIssueLifecycle (lifecycle.py) is the SINGLE SOURCE OF TRUTH:\n\nNEW \u2192 TRIAGED \u2192 APPROVED_FOR_FIX \u2192 SPEC_READY \u2192 BUILDING\n    \u2192 QA_REVIEW \u2192 BUILD_COMPLETE \u2192 PR_CREATED\n    \u2192 PR_AWAITING_CHECKS \u2192 PR_REVIEWING\n    \u2192 PR_CHANGES_REQUESTED \u2192 PR_FIXING \u2192 (loop to PR_AWAITING_CHECKS)\n    \u2192 PR_READY_TO_MERGE \u2192 COMPLETED\n\nNew states to add to IssueLifecycleState enum:\n  - PR_AWAITING_CHECKS\n  - PR_FIXING\n  - PR_READY_TO_MERGE\n```\n\n### Component Overview (Updated)\n\n| Component | Type | Location | Purpose |\n|-----------|------|----------|---------|\n| `AutoPRReviewOrchestrator` | New | `apps/backend/runners/github/services/auto_pr_review_orchestrator.py` | Main orchestration with state persistence |\n| `PRReviewOrchestratorState` | New | `apps/backend/runners/github/models/pr_review_state.py` | Durable state for crash recovery |\n| `PRCheckWaiter` | New | `apps/backend/runners/github/services/pr_check_waiter.py` | Poll with circuit breaker + exponential backoff |\n| `PRFixerAgent` | New | `apps/backend/agents/pr_fixer.py` | Fix findings with safety constraints |\n| `pr_fixer.md` | New | `apps/backend/prompts/github/pr_fixer.md` | System prompt with input sanitization |\n| `InputSanitizer` | New | `apps/backend/runners/github/security/input_sanitizer.py` | Sanitize untrusted inputs |\n| `PermissionManager` | New | `apps/backend/runners/github/security/permission_manager.py` | Authorization checks |\n| `FrontendStateAdapter` | New | `apps/backend/runners/github/adapters/frontend_state.py` | Map IssueLifecycle \u2192 AutoFixQueueItem |\n| `useAutoPRReview.ts` | New | `apps/frontend/.../hooks/useAutoPRReview.ts` | Frontend hook with cancellation |\n| `AutoPRReviewProgressCard` | New | `apps/frontend/.../components/AutoPRReviewProgressCard.tsx` | Rich progress UI |\n\n---\n\n## Implementation Phases (Revised)\n\n### Phase 0: Foundation (Pre-requisites)\n\n**0.1 Extend `IssueLifecycleState`** - `apps/backend/runners/github/lifecycle.py`\n```python\nclass IssueLifecycleState(str, Enum):\n    # ... existing states ...\n    PR_AWAITING_CHECKS = \"pr_awaiting_checks\"  # NEW\n    PR_FIXING = \"pr_fixing\"  # NEW\n    PR_READY_TO_MERGE = \"pr_ready_to_merge\"  # NEW\n\n# Add valid transitions:\nVALID_TRANSITIONS = {\n    PR_CREATED: [PR_AWAITING_CHECKS],\n    PR_AWAITING_CHECKS: [PR_REVIEWING, PR_FIXING],  # CI fail goes to fixing\n    PR_REVIEWING: [PR_CHANGES_REQUESTED, PR_READY_TO_MERGE],\n    PR_CHANGES_REQUESTED: [PR_FIXING],\n    PR_FIXING: [PR_AWAITING_CHECKS],  # Loop back after push\n    PR_READY_TO_MERGE: [COMPLETED],\n}\n```\n\n**0.2 Add Audit Events** - `apps/backend/runners/github/audit.py`\n```python\nclass AuditAction(str, Enum):\n    # ... existing ...\n    PR_REVIEW_LOOP_STARTED = \"pr_review_loop_started\"\n    PR_REVIEW_LOOP_ITERATION = \"pr_review_loop_iteration\"\n    PR_FIXER_STARTED = \"pr_fixer_started\"\n    PR_FIXER_CHANGES_APPLIED = \"pr_fixer_changes_applied\"\n    EXTERNAL_BOT_COMMENT_TRUSTED = \"external_bot_comment_trusted\"\n    PERMISSION_CHECK_PASSED = \"permission_check_passed\"\n    PERMISSION_CHECK_DENIED = \"permission_check_denied\"\n```\n\n---\n\n### Phase 1: Security Infrastructure\n\n**1.1 Create `InputSanitizer`** - `apps/backend/runners/github/security/input_sanitizer.py`\n- Remove prompt injection patterns from issue content\n- Validate file paths in findings (no traversal, no command injection)\n- Strip dangerous Unicode characters\n- Limit content length (10000 chars max)\n\n**1.2 Create `PermissionManager`** - `apps/backend/runners/github/security/permission_manager.py`\n- Check `GITHUB_AUTO_PR_REVIEW_ALLOWED_USERS` env var\n- Default to repository admins/maintainers only\n- Log all authorization decisions to audit trail\n\n**1.3 Add Bot Identity Verification** - `apps/backend/runners/github/services/bot_verifier.py`\n- Maintain allowlist of trusted bot account IDs (not just names)\n- Verify GitHub App signatures where available\n- Check account age and verification status\n- Log all bot detection decisions\n\n---\n\n### Phase 2: Backend Infrastructure (Reliability)\n\n**2.1 Create `PRReviewOrchestratorState`** - `apps/backend/runners/github/models/pr_review_state.py`\n```python\n@dataclass\nclass PRReviewOrchestratorState:\n    \"\"\"Durable state for crash recovery.\"\"\"\n    pr_number: int\n    issue_number: int\n    spec_id: str\n    current_iteration: int\n    max_iterations: int\n    phase: str  # \"awaiting_checks\" | \"pr_reviewing\" | \"pr_fixing\"\n    last_checkpoint_time: str\n    ci_wait_start_time: str | None\n    fix_attempts: int\n    error_history: list[dict]\n    correlation_id: str\n\n    async def save(self, github_dir: Path):\n        \"\"\"Atomic save with file locking.\"\"\"\n        filepath = github_dir / \"pr_review_state\" / f\"pr_{self.pr_number}.json\"\n        await locked_json_write(filepath, self.to_dict())\n\n    @classmethod\n    async def load(cls, github_dir: Path, pr_number: int):\n        \"\"\"Resume from last checkpoint.\"\"\"\n```\n\n**2.2 Create `PRCheckWaiter`** - `apps/backend/runners/github/services/pr_check_waiter.py`\n```python\nclass PRCheckWaiter:\n    def __init__(self, gh_client, config):\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=3,\n            recovery_timeout=300.0\n        )\n        self.backoff = ExponentialBackoff(base=60, max=300, jitter=True)\n        self.expected_bots = self._load_bot_expectations(config.repo)\n\n    async def wait_for_all_checks(\n        self,\n        pr_number: int,\n        cancellation_token: CancellationToken\n    ) -> CheckWaitResult:\n        # Check if PR is still open at each poll\n        # Exponential backoff on API errors\n        # Circuit breaker for sustained failures\n        # Separate tracking for required vs optional bots\n```\n\n**2.3 Create `PRFixerAgent`** - `apps/backend/agents/pr_fixer.py`\n```python\n@dataclass\nclass PRFixerContext:\n    pr_number: int\n    issue_number: int\n    internal_findings: list[PRReviewFinding]\n    external_bot_findings: list[ExternalBotFinding]  # Parsed\n    ci_failures: list[CITestFailure]\n    original_pr_intent: str  # From PR description\n    files_allowed_to_modify: set[str]  # Only files in PR diff\n    architecture_constraints: dict\n\nclass PRFixerAgent:\n    def __init__(self, project_dir, spec_dir, config):\n        self.client = create_client(\n            agent_type=\"pr_fixer\",\n            model=\"claude-sonnet-4-5-20250929\"\n        )\n        self.bot_parsers = {\n            \"coderabbit\": CodeRabbitParser(),\n            \"cursor\": CursorParser(),\n        }\n\n    async def fix_findings(self, context: PRFixerContext) -> PRFixResult:\n        # Sanitize all inputs\n        # Filter to auto-fixable only\n        # Generate fix prompt with safety constraints\n        # Validate syntax before returning\n```\n\n**2.4 Create `AutoPRReviewOrchestrator`** - `apps/backend/runners/github/services/auto_pr_review_orchestrator.py`\n```python\nclass AutoPRReviewOrchestrator:\n    _concurrent_reviews = asyncio.Semaphore(3)  # Global limit\n\n    def __init__(self, ...):\n        self.correlation_id = f\"pr-review-{pr_number}-{datetime.utcnow().isoformat()}\"\n        self.lifecycle_mgr = LifecycleManager(github_dir)\n        self.cancellation_token = CancellationToken()\n        self.telemetry = PRReviewLoopTelemetry(...)\n\n    async def run(self, pr_number, issue_number, spec_id):\n        # 1. Permission check\n        if not self.permission_mgr.can_trigger_auto_pr_review(issue_number):\n            raise PermissionDenied(...)\n\n        # 2. Acquire semaphore (limit concurrent reviews)\n        async with self._concurrent_reviews:\n            # 3. Acquire lifecycle lock\n            if not self.lifecycle_mgr.acquire_lock(repo, issue_number, \"auto_pr_review\"):\n                raise ConcurrentOperationError(...)\n\n            try:\n                # 4. Load or create state for crash recovery\n                state = await PRReviewOrchestratorState.load(...) or PRReviewOrchestratorState(...)\n\n                # 5. Main loop with checkpoints\n                while state.current_iteration < state.max_iterations:\n                    if self.cancellation_token.is_cancelled():\n                        return Cancelled()\n\n                    # Checkpoint BEFORE each phase\n                    await state.save(self.github_dir)\n\n                    # ... (wait for checks, review, fix) ...\n\n                # 6. NEVER auto-merge - just mark ready\n                await self._set_requires_human_approval(pr_number)\n                return Success(ready_to_merge=True, requires_human_approval=True)\n\n            finally:\n                # 7. ALWAYS cleanup\n                await self._cleanup_resources()\n                self.lifecycle_mgr.release_lock(repo, issue_number, \"auto_pr_review\")\n                self.telemetry.save(self.github_dir)\n```\n\n**2.5 Add `pr_fixer` Agent Type** - `apps/backend/core/client.py`\n- Add to agent_type switch\n- Configure appropriate tool permissions\n\n---\n\n### Phase 3: Backend Integration\n\n**3.1 Create `FrontendStateAdapter`** - `apps/backend/runners/github/adapters/frontend_state.py`\n```python\nclass FrontendStateAdapter:\n    \"\"\"Map IssueLifecycle to AutoFixQueueItem format.\"\"\"\n\n    STATUS_MAP = {\n        IssueLifecycleState.NEW: \"pending\",\n        IssueLifecycleState.PR_AWAITING_CHECKS: \"awaiting_checks\",\n        IssueLifecycleState.PR_REVIEWING: \"pr_reviewing\",\n        IssueLifecycleState.PR_FIXING: \"pr_fixing\",\n        IssueLifecycleState.PR_READY_TO_MERGE: \"pr_ready_to_merge\",\n        # ... etc\n    }\n\n    @staticmethod\n    def to_frontend_status(lifecycle: IssueLifecycle, pr_state: PRReviewOrchestratorState = None) -> dict:\n        return {\n            \"status\": STATUS_MAP.get(lifecycle.current_state),\n            \"prReviewIteration\": pr_state.current_iteration if pr_state else None,\n            \"prReviewMaxIterations\": pr_state.max_iterations if pr_state else None,\n            \"ciStatus\": lifecycle.metadata.get(\"ci_status\"),\n            \"externalBotsComplete\": lifecycle.metadata.get(\"bots_complete\"),\n            # Progress info for real-time feedback\n            \"elapsedSeconds\": pr_state.elapsed_seconds if pr_state else None,\n            \"currentSubstep\": pr_state.current_substep if pr_state else None,\n        }\n```\n\n**3.2 Add IPC Handlers** - `apps/frontend/src/main/ipc-handlers/github/autofix-handlers.ts`\n- `GITHUB_AUTO_PR_REVIEW_GET_CONFIG` - Get Auto-PR-Review settings\n- `GITHUB_AUTO_PR_REVIEW_SET_ENABLED` - Toggle Auto-PR-Review\n- `GITHUB_AUTO_PR_REVIEW_START` - Manually trigger PR review loop\n- `GITHUB_AUTO_PR_REVIEW_CANCEL` - Cancel with graceful cleanup\n- `GITHUB_AUTO_PR_REVIEW_GET_QUEUE` - Get queue status\n\n**3.3 Add IPC Events** (Granular Progress)\n```typescript\ninterface AutoPRReviewProgress {\n  phase: 'awaiting_checks' | 'ci_polling' | 'bot_waiting' | 'pr_reviewing' | 'pr_fixing';\n  prNumber: number;\n  iteration: number;\n  maxIterations: number;\n  progress: number; // 0-100\n  message: string;\n  // Granular substep tracking\n  currentSubstep?: string;\n  elapsedSeconds?: number;\n  estimatedSecondsRemaining?: number;\n  // Checkpoint data\n  ciChecksPassed?: number;\n  ciChecksTotal?: number;\n  externalBotsComplete?: string[];\n  externalBotsPending?: string[];\n}\n```\n\n**3.4 Trigger Integration** - Connect QA pass to Auto-PR-Review\n- In `autofix_processor.py`, after `qa_review` \u2192 `pr_created`:\n  - Check `autoPRReviewEnabled` config\n  - If enabled: Start `AutoPRReviewOrchestrator`\n  - Else: Complete as before\n\n---\n\n### Phase 4: Frontend UI (UX Improvements)\n\n**4.1 Create `useAutoPRReview.ts`** - `apps/frontend/src/renderer/components/github-issues/hooks/useAutoPRReview.ts`\n```typescript\nexport function useAutoPRReview(projectId: string) {\n  const [config, setConfig] = useState<AutoPRReviewConfig | null>(null);\n  const [queue, setQueue] = useState<AutoPRReviewQueueItem[]>([]);\n  const [errors, setErrors] = useState<Record<number, PRReviewError>>({});\n\n  // Optimistic toggle\n  const toggleEnabled = useCallback(async (enabled: boolean) => {\n    setConfig(prev => prev ? { ...prev, enabled } : null);  // Optimistic\n    try {\n      await window.electronAPI.github.setAutoPRReviewEnabled(projectId, enabled);\n    } catch (e) {\n      setConfig(prev => prev ? { ...prev, enabled: !enabled } : null);  // Rollback\n    }\n  }, [projectId]);\n\n  // Cancel with confirmation\n  const cancelReview = useCallback(async (prNumber: number) => {\n    // Show confirmation dialog handled in component\n    await window.electronAPI.github.cancelAutoPRReview(projectId, prNumber);\n  }, [projectId]);\n\n  // ... IPC listeners for progress, complete, error\n}\n```\n\n**4.2 Create `AutoPRReviewProgressCard.tsx`** - Rich progress UI\n```tsx\n<ProgressCard>\n  <Header>\n    PR #{prNumber} \u2022 Iteration {iteration}/{maxIterations}\n    <CancelButton onClick={handleCancel}>Cancel</CancelButton>\n  </Header>\n\n  <ProgressBar value={progress} aria-valuenow={progress} />\n\n  <SubstepIndicator>\n    {currentSubstep}\n    <TimeElapsed>{formatDuration(elapsedSeconds)}</TimeElapsed>\n    {estimatedSecondsRemaining && (\n      <TimeRemaining>~{formatDuration(estimatedSecondsRemaining)} remaining</TimeRemaining>\n    )}\n  </SubstepIndicator>\n\n  {/* CI Checks Visualization */}\n  {ciChecksTotal > 0 && (\n    <CheckpointGrid>\n      <Label>CI Checks: {ciChecksPassed}/{ciChecksTotal}</Label>\n    </CheckpointGrid>\n  )}\n\n  {/* Bot Status */}\n  {externalBotsComplete.length > 0 && (\n    <BotStatus>\n      {externalBotsComplete.map(bot => <BotBadge status=\"complete\">{bot}</BotBadge>)}\n      {externalBotsPending.map(bot => <BotBadge status=\"pending\">{bot}</BotBadge>)}\n    </BotStatus>\n  )}\n\n  {/* ARIA live region for screen readers */}\n  <div role=\"status\" aria-live=\"polite\" className=\"sr-only\">\n    {ariaLiveMessage}\n  </div>\n</ProgressCard>\n```\n\n**4.3 Add Toggle to `IssueListHeader.tsx`**\n- Add \"Auto-PR-Review\" toggle next to \"Auto-Fix New\" toggle\n- Show dependency warning if Auto-Fix is disabled\n- Add visual flow indicator showing pipeline stages\n\n**4.4 Add Error Recovery Dialogs**\n```tsx\n<ErrorCard variant=\"destructive\">\n  <ErrorTitle>PR Review Failed: {errorType}</ErrorTitle>\n  <ErrorDescription>{message}</ErrorDescription>\n\n  <RecoveryActions>\n    {errorType === 'max_iterations' && (\n      <>\n        <Button onClick={viewUnresolvedFindings}>View Unresolved Findings</Button>\n        <Button onClick={resetAndRetry}>Reset & Retry</Button>\n        <Button variant=\"destructive\" onClick={forceApprove}>Force Approve (Waive Issues)</Button>\n      </>\n    )}\n    {errorType === 'ci_failure' && (\n      <>\n        <Button onClick={viewCILogs}>View CI Logs</Button>\n        <Button onClick={skipCIAndContinue}>Skip CI & Continue (Warning)</Button>\n      </>\n    )}\n    {errorType === 'bot_timeout' && (\n      <>\n        <Button onClick={waitLonger}>Wait 15 More Minutes</Button>\n        <Button onClick={proceedWithoutBots}>Proceed Without Bots</Button>\n      </>\n    )}\n  </RecoveryActions>\n</ErrorCard>\n```\n\n**4.5 Add Accessibility**\n- ARIA labels on all interactive elements\n- Live region announcements for status changes\n- Keyboard shortcuts (Escape to cancel)\n- Focus management for dialogs\n\n**4.6 i18n Keys** - Complete inventory\n```json\n{\n  \"autoPRReview\": {\n    \"title\": \"Auto-PR-Review\",\n    \"tooltip\": \"Automatically review PRs and fix issues until ready to merge\",\n    \"requiresAutoFix\": \"Enable Auto-Fix first\",\n    \"status\": {\n      \"awaiting_checks\": \"Waiting for Checks\",\n      \"pr_reviewing\": \"AI Reviewing\",\n      \"pr_fixing\": \"Fixing Issues\",\n      \"pr_ready_to_merge\": \"Ready to Merge\",\n      \"cancelled\": \"Cancelled\"\n    },\n    \"messages\": {...},\n    \"errors\": {...},\n    \"actions\": {...},\n    \"dialogs\": {...},\n    \"progress\": {...}\n  }\n}\n```\n\n---\n\n### Phase 5: Observability\n\n**5.1 Structured Logging** - Replace `print()` with `structlog`\n```python\nimport structlog\nlogger = structlog.get_logger()\n\n# All log entries include correlation_id\nlog = logger.bind(\n    correlation_id=self.correlation_id,\n    pr_number=pr_number,\n    issue_number=issue_number\n)\nlog.info(\"orchestrator.iteration.start\", iteration=iteration)\n```\n\n**5.2 Telemetry Collection**\n```python\n@dataclass\nclass PRReviewLoopTelemetry:\n    pr_number: int\n    start_time: datetime\n    iterations: list[IterationTelemetry]\n    final_state: str\n    total_duration_seconds: float\n\n    def save(self, github_dir: Path):\n        path = github_dir / \"pr_review_telemetry\" / f\"pr_{self.pr_number}.json\"\n        path.parent.mkdir(parents=True, exist_ok=True)\n        with open(path, \"w\") as f:\n            json.dump(asdict(self), f, indent=2, default=str)\n```\n\n**5.3 Health Check Endpoint** - IPC handler\n```typescript\n// GITHUB_AUTO_PR_REVIEW_HEALTH\n{\n  status: \"healthy\" | \"degraded\",\n  activeReviews: 2,\n  queuedReviews: 5,\n  circuitBreakerState: \"closed\" | \"open\",\n  rateLimiterTokens: 45,\n  lastError: null\n}\n```\n\n---\n\n### Phase 6: Testing\n\n**6.1 Unit Tests**\n- `PRCheckWaiter` - Mock GitHub API, test timeout/backoff/circuit breaker\n- `PRFixerAgent` - Mock Claude SDK, test fix generation, syntax validation\n- `AutoPRReviewOrchestrator` - Test state transitions, max iterations, cancellation\n- `InputSanitizer` - Test prompt injection patterns, path traversal\n- `PermissionManager` - Test allowlist, deny scenarios\n\n**6.2 Edge Case Tests**\n- PR closed during review \u2192 graceful exit, cleanup\n- PR merged externally \u2192 detect and exit\n- CI never completes \u2192 timeout handling\n- Bot never comments \u2192 proceed after timeout\n- Fixer creates invalid code \u2192 detect syntax error, retry or fail\n- Force push during review \u2192 detect SHA mismatch, restart\n- User pushes during fixing \u2192 handle merge conflict\n\n**6.3 Integration Tests**\n- Full flow: Issue \u2192 Task \u2192 Build \u2192 QA \u2192 PR \u2192 Review \u2192 Ready\n- Error scenarios: CI failure, max iterations, bot timeout\n- Concurrent operations: 3 PRs simultaneously\n- Crash recovery: Kill process mid-loop, verify resume\n\n**6.4 State Machine Property Tests**\n```python\n@given(st.lists(st.sampled_from(IssueLifecycleState)))\ndef test_state_machine_invariants(state_sequence):\n    \"\"\"Property test: State machine maintains invariants.\"\"\"\n```\n\n---\n\n### Phase 7: Gradual Rollout\n\n**7.1 Feature Flag** - Start disabled by default\n```bash\nGITHUB_AUTO_PR_REVIEW_ENABLED=false  # Global kill switch\n```\n\n**7.2 Manual Trigger First**\n- Start with manual \"Start Auto-Review\" button per PR\n- Learn operational patterns before full automation\n\n**7.3 Monitoring**\n- Dashboard for review queue, iteration counts, success rate\n- Alerts for stuck reviews (>30 min in one phase)\n- Alert for high failure rate (>20% in 24h)\n\n**7.4 Internal Dogfooding**\n- 2 weeks on sandbox repos\n- 2 weeks on internal repos only\n- Then enable for production repos\n\n---\n\n## Critical Files to Modify\n\n### Backend (Python)\n| File | Action |\n|------|--------|\n| `apps/backend/runners/github/lifecycle.py` | Add new states + transitions |\n| `apps/backend/runners/github/audit.py` | Add new audit events |\n| `apps/backend/runners/github/security/input_sanitizer.py` | NEW |\n| `apps/backend/runners/github/security/permission_manager.py` | NEW |\n| `apps/backend/runners/github/models/pr_review_state.py` | NEW |\n| `apps/backend/runners/github/services/pr_check_waiter.py` | NEW |\n| `apps/backend/runners/github/services/auto_pr_review_orchestrator.py` | NEW |\n| `apps/backend/runners/github/adapters/frontend_state.py` | NEW |\n| `apps/backend/agents/pr_fixer.py` | NEW |\n| `apps/backend/prompts/github/pr_fixer.md` | NEW |\n| `apps/backend/core/client.py` | Add `pr_fixer` agent type |\n\n### Frontend (TypeScript)\n| File | Action |\n|------|--------|\n| `apps/frontend/src/preload/api/modules/github-api.ts` | Extend types |\n| `apps/frontend/src/shared/constants.ts` | Add IPC channels |\n| `apps/frontend/src/main/ipc-handlers/github/autofix-handlers.ts` | New handlers |\n| `apps/frontend/src/renderer/components/github-issues/hooks/useAutoPRReview.ts` | NEW |\n| `apps/frontend/src/renderer/components/github-issues/components/AutoPRReviewProgressCard.tsx` | NEW |\n| `apps/frontend/src/renderer/components/github-issues/components/IssueListHeader.tsx` | Add toggle |\n| `apps/frontend/src/renderer/components/github-issues/types.ts` | Extend props |\n| `apps/frontend/src/shared/i18n/locales/en/github.json` | Add translations |\n| `apps/frontend/src/shared/i18n/locales/fr/github.json` | Add translations |\n\n---\n\n## Risk Mitigations (Updated)\n\n| Risk | Mitigation | Status |\n|------|------------|--------|\n| Dual state systems | Use `IssueLifecycle` as single source of truth | \u2705 Addressed |\n| Race conditions | Mandatory locking via `LifecycleManager` | \u2705 Addressed |\n| Crash during loop | State persistence with checkpoint/resume | \u2705 Addressed |\n| Rate limit exhaustion | Circuit breaker + exponential backoff | \u2705 Addressed |\n| Prompt injection | `InputSanitizer` for all untrusted content | \u2705 Addressed |\n| Unauthorized access | `PermissionManager` with allowlist | \u2705 Addressed |\n| Auto-merge danger | NEVER auto-merge, require human approval | \u2705 Addressed |\n| No cancellation | `CancellationToken` + cleanup | \u2705 Addressed |\n| Silent failures | Structured logging + correlation IDs | \u2705 Addressed |\n| Infinite fix loop | Max iterations + recurring issue detection | \u2705 Original |\n| CI flakiness | Retry once before triggering fixer | \u2705 Original |\n| External bot delays | 15-min timeout, proceed anyway | \u2705 Original |\n| Concurrent PRs | Semaphore limit (3 concurrent) | \u2705 Implemented |\n\n---\n\n## Configuration Defaults\n\n```json\n{\n  \"autoPRReviewEnabled\": false,\n  \"autoPRReviewConfig\": {\n    \"maxPRReviewIterations\": 5,\n    \"ciCheckTimeout\": 1800000,\n    \"externalBotTimeout\": 900000,\n    \"pollInterval\": 60000,\n    \"requireHumanApproval\": true,\n    \"allowedUsers\": []\n  }\n}\n```\n\n---\n\n## Summary\n\nThis **revised** implementation addresses all critical gaps identified by the 5 expert critiques:\n\n1. **State Machine Integration** - Single source of truth via `IssueLifecycle`\n2. **Concurrency Control** - Mandatory locking, semaphore for concurrent reviews\n3. **State Persistence** - Crash recovery via checkpointed state\n4. **Circuit Breakers** - Prevent API exhaustion during polling\n5. **Input Sanitization** - Protect against prompt injection\n6. **Authorization** - Allowlist for who can trigger automation\n7. **Human Approval Required** - NEVER auto-merge\n8. **Real-time Feedback** - Granular progress with elapsed/estimated time\n9. **Cancellation UX** - Graceful cancellation with cleanup\n10. **Error Recovery** - Actionable recovery options for all failure modes\n11. **Accessibility** - ARIA labels, keyboard navigation, screen reader support\n12. **Observability** - Structured logging, telemetry, health checks\n13. **Comprehensive Testing** - Edge cases, race conditions, crash recovery\n\n**Total Estimated Effort**: 6-8 weeks for production-ready system\n- Phase 0-1 (Foundation + Security): 1-2 weeks\n- Phase 2-3 (Backend): 2 weeks\n- Phase 4 (Frontend): 1-2 weeks\n- Phase 5-6 (Observability + Testing): 1-2 weeks\n- Phase 7 (Rollout): 2-4 weeks monitoring",
  "scoped_services": [],
  "files_to_modify": [],
  "files_to_reference": [],
  "created_at": "2026-01-08T22:58:18.051376"
}
name: PR Management

# Consolidated PR automation:
# - Sets initial "Checking" status label on PR open/sync
# - Auto-labels PRs by type (conventional commits), area (files changed), and size
# - Updates status to "Ready for Review" or "Checks Failed" after CI completes

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_run:
    workflows: [CI]
    types: [completed]

concurrency:
  group: pr-mgmt-${{ github.event.pull_request.number || github.event.workflow_run.pull_requests[0].number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  checks: read

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # INITIAL LABELING - Runs on PR open/sync
  # Sets "Checking" status and auto-labels by type/area/size
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  label-and-status:
    name: Label & Set Status
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
    timeout-minutes: 5
    steps:
      - name: Auto-label and set checking status
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const title = pr.title;

            console.log(`::group::PR #${prNumber} - Auto-labeling and setting status`);
            console.log(`Title: ${title}`);

            const labelsToAdd = new Set();
            const labelsToRemove = new Set();

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // STATUS LABELS - Set to "Checking"
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const statusLabels = ['ğŸ”„ Checking', 'âœ… Ready for Review', 'âŒ Checks Failed'];

            // Remove old status labels
            for (const label of statusLabels) {
              labelsToRemove.add(label);
            }
            labelsToAdd.add('ğŸ”„ Checking');

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TYPE LABELS (from PR title - Conventional Commits)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const typeMap = {
              'feat': 'feature',
              'fix': 'bug',
              'docs': 'documentation',
              'refactor': 'refactor',
              'test': 'test',
              'ci': 'ci',
              'chore': 'chore',
              'perf': 'performance',
              'style': 'style',
              'build': 'build'
            };

            const typeMatch = title.match(/^(\w+)(\(.+?\))?(!)?:/);
            if (typeMatch) {
              const type = typeMatch[1].toLowerCase();
              const isBreaking = typeMatch[3] === '!';

              if (typeMap[type]) {
                labelsToAdd.add(typeMap[type]);
                console.log(`  Type: ${type} -> ${typeMap[type]}`);
              }

              if (isBreaking) {
                labelsToAdd.add('breaking-change');
                console.log(`  Breaking change detected`);
              }
            } else {
              console.log(`  No conventional commit prefix found in title`);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AREA LABELS (from changed files)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let files = [];
            try {
              const { data } = await github.rest.pulls.listFiles({
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100
              });
              files = data;
            } catch (e) {
              console.log(`  Could not fetch files: ${e.message}`);
            }

            const areas = {
              frontend: false,
              backend: false,
              ci: false,
              docs: false,
              tests: false
            };

            for (const file of files) {
              const path = file.filename;
              if (path.startsWith('apps/frontend/')) areas.frontend = true;
              if (path.startsWith('apps/backend/')) areas.backend = true;
              if (path.startsWith('.github/')) areas.ci = true;
              if (path.endsWith('.md') || path.startsWith('docs/')) areas.docs = true;
              if (path.startsWith('tests/') || path.includes('.test.') || path.includes('.spec.')) areas.tests = true;
            }

            // Determine area label (mutually exclusive)
            const areaLabels = ['area/frontend', 'area/backend', 'area/fullstack', 'area/ci'];

            if (areas.frontend && areas.backend) {
              labelsToAdd.add('area/fullstack');
              areaLabels.filter(l => l !== 'area/fullstack').forEach(l => labelsToRemove.add(l));
              console.log(`  Area: fullstack (${files.length} files)`);
            } else if (areas.frontend) {
              labelsToAdd.add('area/frontend');
              areaLabels.filter(l => l !== 'area/frontend').forEach(l => labelsToRemove.add(l));
              console.log(`  Area: frontend (${files.length} files)`);
            } else if (areas.backend) {
              labelsToAdd.add('area/backend');
              areaLabels.filter(l => l !== 'area/backend').forEach(l => labelsToRemove.add(l));
              console.log(`  Area: backend (${files.length} files)`);
            } else if (areas.ci) {
              labelsToAdd.add('area/ci');
              areaLabels.filter(l => l !== 'area/ci').forEach(l => labelsToRemove.add(l));
              console.log(`  Area: ci (${files.length} files)`);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SIZE LABELS (from lines changed)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const additions = pr.additions || 0;
            const deletions = pr.deletions || 0;
            const totalLines = additions + deletions;

            const sizeLabels = ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'];
            let sizeLabel;

            if (totalLines < 10) sizeLabel = 'size/XS';
            else if (totalLines < 100) sizeLabel = 'size/S';
            else if (totalLines < 500) sizeLabel = 'size/M';
            else if (totalLines < 1000) sizeLabel = 'size/L';
            else sizeLabel = 'size/XL';

            labelsToAdd.add(sizeLabel);
            sizeLabels.filter(l => l !== sizeLabel).forEach(l => labelsToRemove.add(l));
            console.log(`  Size: ${sizeLabel} (+${additions}/-${deletions} = ${totalLines} lines)`);

            console.log('::endgroup::');

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // APPLY LABELS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.log(`::group::Applying labels`);

            // Remove old labels (in parallel)
            const removeArray = [...labelsToRemove].filter(l => !labelsToAdd.has(l));
            if (removeArray.length > 0) {
              const removePromises = removeArray.map(async (label) => {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: prNumber,
                    name: label
                  });
                  console.log(`  Removed: ${label}`);
                } catch (e) {
                  if (e.status !== 404) {
                    console.log(`  Could not remove ${label}: ${e.message}`);
                  }
                }
              });
              await Promise.all(removePromises);
            }

            // Add new labels
            const addArray = [...labelsToAdd];
            if (addArray.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: prNumber,
                  labels: addArray
                });
                console.log(`  Added: ${addArray.join(', ')}`);
              } catch (e) {
                // Some labels might not exist - try one by one
                if (e.status === 404) {
                  core.warning(`Some labels do not exist. Please create them in repository settings.`);
                  for (const label of addArray) {
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: prNumber,
                        labels: [label]
                      });
                    } catch (e2) {
                      console.log(`  Label '${label}' does not exist`);
                    }
                  }
                } else {
                  throw e;
                }
              }
            }

            console.log('::endgroup::');

            // Summary
            console.log(`PR #${prNumber} labeled: ${addArray.join(', ')}`);

            // Write job summary
            core.summary
              .addHeading(`PR #${prNumber} - Labels Applied`, 3)
              .addTable([
                [{data: 'Category', header: true}, {data: 'Label', header: true}],
                ['Status', 'ğŸ”„ Checking'],
                ['Type', typeMatch ? typeMap[typeMatch[1].toLowerCase()] || 'none' : 'none'],
                ['Area', areas.frontend && areas.backend ? 'fullstack' : areas.frontend ? 'frontend' : areas.backend ? 'backend' : areas.ci ? 'ci' : 'other'],
                ['Size', sizeLabel]
              ])
              .addRaw(`\n**Files changed:** ${files.length}\n`)
              .addRaw(`**Lines:** +${additions} / -${deletions}\n`);
            await core.summary.write();

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STATUS UPDATE - Runs after CI workflow completes
  # Updates PR label to "Ready for Review" or "Checks Failed"
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-status:
    name: Update PR Status
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.pull_requests[0] != null
    timeout-minutes: 5
    steps:
      - name: Check all required checks and update label
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.workflow_run.pull_requests[0].number;
            const headSha = context.payload.workflow_run.head_sha;
            const triggerWorkflow = context.payload.workflow_run.name;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // REQUIRED CHECK RUNS - Job-level checks from consolidated CI
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Format: "{Workflow Name} / {Job Name}"
            //
            // To find check names: Go to PR -> Checks tab -> copy exact name
            // To update: Edit this list when workflow jobs are added/renamed/removed
            //
            // Last validated: 2026-01-02
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const requiredChecks = [
              // CI workflow (ci.yml) - consolidated checks
              'CI / Detect Changes',
              'CI / test-frontend',
              'CI / test-python (3.12)',
              'CI / test-python (3.13)',
              'CI / lint-python',
              'CI / codeql (python)',
              'CI / codeql (javascript-typescript)',
              'CI / python-security',
              'CI / security-summary',
              'CI / CI Status'
            ];

            const statusLabels = {
              checking: 'ğŸ”„ Checking',
              passed: 'âœ… Ready for Review',
              failed: 'âŒ Checks Failed'
            };

            console.log(`::group::PR #${prNumber} - Checking required checks`);
            console.log(`Triggered by: ${triggerWorkflow}`);
            console.log(`Head SHA: ${headSha}`);
            console.log(`Required checks: ${requiredChecks.length}`);
            console.log('');

            // Fetch all check runs for this commit
            let allCheckRuns = [];
            try {
              const { data } = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: headSha,
                per_page: 100
              });
              allCheckRuns = data.check_runs;
              console.log(`Found ${allCheckRuns.length} total check runs`);
            } catch (error) {
              core.warning(`Failed to fetch check runs for PR #${prNumber}: ${error.message}. PR label may be outdated.`);
              console.log(`::error::Failed to fetch check runs: ${error.message}`);
              console.log('::endgroup::');
              return;
            }

            let allComplete = true;
            let anyFailed = false;
            const results = [];

            // Check each required check
            for (const checkName of requiredChecks) {
              const check = allCheckRuns.find(c => c.name === checkName);

              if (!check) {
                results.push({ name: checkName, status: 'Pending', complete: false });
                allComplete = false;
              } else if (check.status !== 'completed') {
                results.push({ name: checkName, status: 'Running', complete: false });
                allComplete = false;
              } else if (check.conclusion === 'success') {
                results.push({ name: checkName, status: 'Passed', complete: true });
              } else if (check.conclusion === 'skipped') {
                // Skipped checks are treated as passed (e.g., path filters, conditional jobs)
                results.push({ name: checkName, status: 'Skipped', complete: true, skipped: true });
              } else {
                results.push({ name: checkName, status: 'Failed', complete: true, failed: true });
                anyFailed = true;
              }
            }

            // Print results table
            console.log('');
            console.log('Check Status:');
            console.log('-'.repeat(70));
            for (const r of results) {
              const shortName = r.name.length > 55 ? r.name.substring(0, 52) + '...' : r.name;
              console.log(`  ${r.status.padEnd(12)} ${shortName}`);
            }
            console.log('-'.repeat(70));
            console.log('::endgroup::');

            // Only update label if all required checks are complete
            if (!allComplete) {
              const pending = results.filter(r => !r.complete).length;
              console.log(`${pending}/${requiredChecks.length} checks still pending - keeping current label`);
              return;
            }

            // Determine final label
            const newLabel = anyFailed ? statusLabels.failed : statusLabels.passed;

            console.log(`::group::Updating PR #${prNumber} label`);

            // Remove old status labels
            for (const label of Object.values(statusLabels)) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: prNumber,
                  name: label
                });
                console.log(`  Removed: ${label}`);
              } catch (e) {
                if (e.status !== 404) {
                  console.log(`  Could not remove ${label}: ${e.message}`);
                }
              }
            }

            // Add final status label
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: [newLabel]
              });
              console.log(`  Added: ${newLabel}`);
            } catch (e) {
              if (e.status === 404) {
                core.warning(`Label '${newLabel}' does not exist. Please create it in repository settings.`);
              }
              throw e;
            }

            console.log('::endgroup::');

            // Summary
            const passedCount = results.filter(r => r.status === 'Passed').length;
            const skippedCount = results.filter(r => r.skipped).length;
            const failedCount = results.filter(r => r.failed).length;

            if (anyFailed) {
              console.log(`PR #${prNumber} has ${failedCount} failing check(s)`);
              core.summary.addRaw(`## PR #${prNumber} - Checks Failed\n\n`);
              core.summary.addRaw(`**${failedCount}** of **${requiredChecks.length}** required checks failed.\n\n`);
            } else {
              const skippedNote = skippedCount > 0 ? ` (${skippedCount} skipped)` : '';
              const totalSuccessful = passedCount + skippedCount;
              console.log(`PR #${prNumber} is ready for review (${totalSuccessful}/${requiredChecks.length} checks succeeded${skippedNote})`);
              core.summary.addRaw(`## PR #${prNumber} - Ready for Review\n\n`);
              core.summary.addRaw(`All **${requiredChecks.length}** required checks succeeded${skippedNote}.\n\n`);
            }

            // Add results to summary
            core.summary.addTable([
              [{data: 'Check', header: true}, {data: 'Status', header: true}],
              ...results.map(r => [r.name, r.status])
            ]);
            await core.summary.write();
